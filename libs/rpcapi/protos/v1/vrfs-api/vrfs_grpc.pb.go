// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: libs/rpcapi/protos/v1/vrfs-api/vrfs.proto

package vrfs_api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VerifiableRemoteFileStorageClient is the client API for VerifiableRemoteFileStorage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VerifiableRemoteFileStorageClient interface {
	// Request for a file bucket on the remote files storage server
	UploadBucket(ctx context.Context, in *UploadBucketRequest, opts ...grpc.CallOption) (*UploadBucketResponse, error)
	// Confirm that files have been remotely stored and are consistent with the original/local fileset
	UploadDone(ctx context.Context, in *UploadDoneRequest, opts ...grpc.CallOption) (*UploadDoneResponse, error)
	// Get the download info to retrieve a file from the files storage server as well as
	// the MerkleTree proofs to confirm it has not been tampered
	DownloadFileInfo(ctx context.Context, in *DownloadFileInfoRequest, opts ...grpc.CallOption) (*DownloadFileInfoResponse, error)
	// Dummy ping request: check that the service is available & responsive
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error)
}

type verifiableRemoteFileStorageClient struct {
	cc grpc.ClientConnInterface
}

func NewVerifiableRemoteFileStorageClient(cc grpc.ClientConnInterface) VerifiableRemoteFileStorageClient {
	return &verifiableRemoteFileStorageClient{cc}
}

func (c *verifiableRemoteFileStorageClient) UploadBucket(ctx context.Context, in *UploadBucketRequest, opts ...grpc.CallOption) (*UploadBucketResponse, error) {
	out := new(UploadBucketResponse)
	err := c.cc.Invoke(ctx, "/vrfs.VerifiableRemoteFileStorage/UploadBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableRemoteFileStorageClient) UploadDone(ctx context.Context, in *UploadDoneRequest, opts ...grpc.CallOption) (*UploadDoneResponse, error) {
	out := new(UploadDoneResponse)
	err := c.cc.Invoke(ctx, "/vrfs.VerifiableRemoteFileStorage/UploadDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableRemoteFileStorageClient) DownloadFileInfo(ctx context.Context, in *DownloadFileInfoRequest, opts ...grpc.CallOption) (*DownloadFileInfoResponse, error) {
	out := new(DownloadFileInfoResponse)
	err := c.cc.Invoke(ctx, "/vrfs.VerifiableRemoteFileStorage/DownloadFileInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableRemoteFileStorageClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error) {
	out := new(PingReply)
	err := c.cc.Invoke(ctx, "/vrfs.VerifiableRemoteFileStorage/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VerifiableRemoteFileStorageServer is the server API for VerifiableRemoteFileStorage service.
// All implementations must embed UnimplementedVerifiableRemoteFileStorageServer
// for forward compatibility
type VerifiableRemoteFileStorageServer interface {
	// Request for a file bucket on the remote files storage server
	UploadBucket(context.Context, *UploadBucketRequest) (*UploadBucketResponse, error)
	// Confirm that files have been remotely stored and are consistent with the original/local fileset
	UploadDone(context.Context, *UploadDoneRequest) (*UploadDoneResponse, error)
	// Get the download info to retrieve a file from the files storage server as well as
	// the MerkleTree proofs to confirm it has not been tampered
	DownloadFileInfo(context.Context, *DownloadFileInfoRequest) (*DownloadFileInfoResponse, error)
	// Dummy ping request: check that the service is available & responsive
	Ping(context.Context, *PingRequest) (*PingReply, error)
	mustEmbedUnimplementedVerifiableRemoteFileStorageServer()
}

// UnimplementedVerifiableRemoteFileStorageServer must be embedded to have forward compatible implementations.
type UnimplementedVerifiableRemoteFileStorageServer struct {
}

func (UnimplementedVerifiableRemoteFileStorageServer) UploadBucket(context.Context, *UploadBucketRequest) (*UploadBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadBucket not implemented")
}
func (UnimplementedVerifiableRemoteFileStorageServer) UploadDone(context.Context, *UploadDoneRequest) (*UploadDoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadDone not implemented")
}
func (UnimplementedVerifiableRemoteFileStorageServer) DownloadFileInfo(context.Context, *DownloadFileInfoRequest) (*DownloadFileInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadFileInfo not implemented")
}
func (UnimplementedVerifiableRemoteFileStorageServer) Ping(context.Context, *PingRequest) (*PingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedVerifiableRemoteFileStorageServer) mustEmbedUnimplementedVerifiableRemoteFileStorageServer() {
}

// UnsafeVerifiableRemoteFileStorageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VerifiableRemoteFileStorageServer will
// result in compilation errors.
type UnsafeVerifiableRemoteFileStorageServer interface {
	mustEmbedUnimplementedVerifiableRemoteFileStorageServer()
}

func RegisterVerifiableRemoteFileStorageServer(s grpc.ServiceRegistrar, srv VerifiableRemoteFileStorageServer) {
	s.RegisterService(&VerifiableRemoteFileStorage_ServiceDesc, srv)
}

func _VerifiableRemoteFileStorage_UploadBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableRemoteFileStorageServer).UploadBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vrfs.VerifiableRemoteFileStorage/UploadBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableRemoteFileStorageServer).UploadBucket(ctx, req.(*UploadBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableRemoteFileStorage_UploadDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadDoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableRemoteFileStorageServer).UploadDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vrfs.VerifiableRemoteFileStorage/UploadDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableRemoteFileStorageServer).UploadDone(ctx, req.(*UploadDoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableRemoteFileStorage_DownloadFileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadFileInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableRemoteFileStorageServer).DownloadFileInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vrfs.VerifiableRemoteFileStorage/DownloadFileInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableRemoteFileStorageServer).DownloadFileInfo(ctx, req.(*DownloadFileInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableRemoteFileStorage_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableRemoteFileStorageServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vrfs.VerifiableRemoteFileStorage/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableRemoteFileStorageServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VerifiableRemoteFileStorage_ServiceDesc is the grpc.ServiceDesc for VerifiableRemoteFileStorage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VerifiableRemoteFileStorage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vrfs.VerifiableRemoteFileStorage",
	HandlerType: (*VerifiableRemoteFileStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadBucket",
			Handler:    _VerifiableRemoteFileStorage_UploadBucket_Handler,
		},
		{
			MethodName: "UploadDone",
			Handler:    _VerifiableRemoteFileStorage_UploadDone_Handler,
		},
		{
			MethodName: "DownloadFileInfo",
			Handler:    _VerifiableRemoteFileStorage_DownloadFileInfo_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _VerifiableRemoteFileStorage_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "libs/rpcapi/protos/v1/vrfs-api/vrfs.proto",
}
